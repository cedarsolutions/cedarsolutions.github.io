<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CedarBackup3.writers.cdwriter &#8212; Cedar Backup v3  documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="top" title="Cedar Backup v3  documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Cedar Backup v3  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for CedarBackup3.writers.cdwriter</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: iso-8859-1 -*-</span>
<span class="c1"># vim: set ft=python ts=3 sw=3 expandtab:</span>
<span class="c1"># # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #</span>
<span class="c1">#</span>
<span class="c1">#              C E D A R</span>
<span class="c1">#          S O L U T I O N S       &quot;Software done right.&quot;</span>
<span class="c1">#           S O F T W A R E</span>
<span class="c1">#</span>
<span class="c1"># # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2004-2008,2010,2015 Kenneth J. Pronovici.</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or</span>
<span class="c1"># modify it under the terms of the GNU General Public License,</span>
<span class="c1"># Version 2, as published by the Free Software Foundation.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1">#</span>
<span class="c1"># Copies of the GNU General Public License are available from</span>
<span class="c1"># the Free Software Foundation website, http://www.gnu.org/.</span>
<span class="c1">#</span>
<span class="c1"># # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #</span>
<span class="c1">#</span>
<span class="c1"># Author   : Kenneth J. Pronovici &lt;pronovic@ieee.org&gt;</span>
<span class="c1"># Language : Python 3 (&gt;= 3.4)</span>
<span class="c1"># Project  : Cedar Backup, release 3</span>
<span class="c1"># Purpose  : Provides functionality related to CD writer devices.</span>
<span class="c1">#</span>
<span class="c1"># # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #</span>

<span class="c1">########################################################################</span>
<span class="c1"># Module documentation</span>
<span class="c1">########################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides functionality related to CD writer devices.</span>

<span class="sd">Module Attributes</span>
<span class="sd">=================</span>

<span class="sd">Attributes:</span>
<span class="sd">   MEDIA_CDRW_74: Constant representing 74-minute CD-RW media</span>
<span class="sd">   MEDIA_CDR_74: Constant representing 74-minute CD-R media</span>
<span class="sd">   MEDIA_CDRW_80: Constant representing 80-minute CD-RW media</span>
<span class="sd">   MEDIA_CDR_80: Constant representing 80-minute CD-R media</span>

<span class="sd">:author: Kenneth J. Pronovici &lt;pronovic@ieee.org&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">########################################################################</span>
<span class="c1"># Imported modules</span>
<span class="c1">########################################################################</span>

<span class="c1"># System modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Cedar Backup modules</span>
<span class="kn">from</span> <span class="nn">CedarBackup3.util</span> <span class="k">import</span> <span class="n">resolveCommand</span><span class="p">,</span> <span class="n">executeCommand</span>
<span class="kn">from</span> <span class="nn">CedarBackup3.util</span> <span class="k">import</span> <span class="n">convertSize</span><span class="p">,</span> <span class="n">displayBytes</span><span class="p">,</span> <span class="n">encodePath</span>
<span class="kn">from</span> <span class="nn">CedarBackup3.util</span> <span class="k">import</span> <span class="n">UNIT_SECTORS</span><span class="p">,</span> <span class="n">UNIT_BYTES</span><span class="p">,</span> <span class="n">UNIT_KBYTES</span><span class="p">,</span> <span class="n">UNIT_MBYTES</span>
<span class="kn">from</span> <span class="nn">CedarBackup3.writers.util</span> <span class="k">import</span> <span class="n">validateDevice</span><span class="p">,</span> <span class="n">validateScsiId</span><span class="p">,</span> <span class="n">validateDriveSpeed</span>
<span class="kn">from</span> <span class="nn">CedarBackup3.writers.util</span> <span class="k">import</span> <span class="n">IsoImage</span>


<span class="c1">########################################################################</span>
<span class="c1"># Module-wide constants and variables</span>
<span class="c1">########################################################################</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;CedarBackup3.log.writers.cdwriter&quot;</span><span class="p">)</span>

<span class="n">MEDIA_CDRW_74</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="n">MEDIA_CDR_74</span>   <span class="o">=</span> <span class="mi">2</span>
<span class="n">MEDIA_CDRW_80</span>  <span class="o">=</span> <span class="mi">3</span>
<span class="n">MEDIA_CDR_80</span>   <span class="o">=</span> <span class="mi">4</span>

<span class="n">CDRECORD_COMMAND</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;cdrecord&quot;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">EJECT_COMMAND</span>    <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;eject&quot;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">MKISOFS_COMMAND</span>  <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;mkisofs&quot;</span><span class="p">,</span> <span class="p">]</span>


<span class="c1">########################################################################</span>
<span class="c1"># MediaDefinition class definition</span>
<span class="c1">########################################################################</span>

<div class="viewcode-block" id="MediaDefinition"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.MediaDefinition">[docs]</a><span class="k">class</span> <span class="nc">MediaDefinition</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Class encapsulating information about CD media definitions.</span>

<span class="sd">   The following media types are accepted:</span>

<span class="sd">      - ``MEDIA_CDR_74``: 74-minute CD-R media (650 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDRW_74``: 74-minute CD-RW media (650 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDR_80``: 80-minute CD-R media (700 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDRW_80``: 80-minute CD-RW media (700 MB capacity)</span>

<span class="sd">   Note that all of the capacities associated with a media definition are in</span>
<span class="sd">   terms of ISO sectors (``util.ISO_SECTOR_SIZE)``.</span>

<span class="sd">   &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MediaDefinition.__init__"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.MediaDefinition.__init__">[docs]</a>   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mediaType</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Creates a media definition for the indicated media type.</span>
<span class="sd">      Args:</span>
<span class="sd">         mediaType: Type of the media, as discussed above</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If the media type is unknown or unsupported</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_initialLeadIn</span> <span class="o">=</span> <span class="mf">0.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_leadIn</span> <span class="o">=</span> <span class="mf">0.0</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="mf">0.0</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_setValues</span><span class="p">(</span><span class="n">mediaType</span><span class="p">)</span></div>

   <span class="k">def</span> <span class="nf">_setValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mediaType</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Sets values based on media type.</span>
<span class="sd">      Args:</span>
<span class="sd">         mediaType: Type of the media, as discussed above</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If the media type is unknown or unsupported</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">mediaType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MEDIA_CDR_74</span><span class="p">,</span> <span class="n">MEDIA_CDRW_74</span><span class="p">,</span> <span class="n">MEDIA_CDR_80</span><span class="p">,</span> <span class="n">MEDIA_CDRW_80</span><span class="p">]:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid media type </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">mediaType</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">=</span> <span class="n">mediaType</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_initialLeadIn</span> <span class="o">=</span> <span class="mf">11400.0</span>   <span class="c1"># per cdrecord&#39;s documentation</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_leadIn</span> <span class="o">=</span> <span class="mf">6900.0</span>           <span class="c1"># per cdrecord&#39;s documentation</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">==</span> <span class="n">MEDIA_CDR_74</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="mf">650.0</span><span class="p">,</span> <span class="n">UNIT_MBYTES</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">==</span> <span class="n">MEDIA_CDRW_74</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span> <span class="o">=</span> <span class="kc">True</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="mf">650.0</span><span class="p">,</span> <span class="n">UNIT_MBYTES</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">==</span> <span class="n">MEDIA_CDR_80</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span> <span class="o">=</span> <span class="kc">False</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="mf">700.0</span><span class="p">,</span> <span class="n">UNIT_MBYTES</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span> <span class="o">==</span> <span class="n">MEDIA_CDRW_80</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span> <span class="o">=</span> <span class="kc">True</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="mf">700.0</span><span class="p">,</span> <span class="n">UNIT_MBYTES</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">_getMediaType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the media type value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mediaType</span>

   <span class="k">def</span> <span class="nf">_getRewritable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the rewritable flag value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rewritable</span>

   <span class="k">def</span> <span class="nf">_getInitialLeadIn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the initial lead-in value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialLeadIn</span>

   <span class="k">def</span> <span class="nf">_getLeadIn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the lead-in value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leadIn</span>

   <span class="k">def</span> <span class="nf">_getCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the capacity value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capacity</span>

   <span class="n">mediaType</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMediaType</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Configured media type.&quot;</span><span class="p">)</span>
   <span class="n">rewritable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getRewritable</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Boolean indicating whether the media is rewritable.&quot;</span><span class="p">)</span>
   <span class="n">initialLeadIn</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getInitialLeadIn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Initial lead-in required for first image written to media.&quot;</span><span class="p">)</span>
   <span class="n">leadIn</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getLeadIn</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Lead-in required on successive images written to media.&quot;</span><span class="p">)</span>
   <span class="n">capacity</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getCapacity</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Total capacity of the media before any required lead-in.&quot;</span><span class="p">)</span></div>


<span class="c1">########################################################################</span>
<span class="c1"># MediaCapacity class definition</span>
<span class="c1">########################################################################</span>

<div class="viewcode-block" id="MediaCapacity"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.MediaCapacity">[docs]</a><span class="k">class</span> <span class="nc">MediaCapacity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Class encapsulating information about CD media capacity.</span>

<span class="sd">   Space used includes the required media lead-in (unless the disk is unused).</span>
<span class="sd">   Space available attempts to provide a picture of how many bytes are</span>
<span class="sd">   available for data storage, including any required lead-in.</span>

<span class="sd">   The boundaries value is either ``None`` (if multisession discs are not</span>
<span class="sd">   supported or if the disc has no boundaries) or in exactly the form provided</span>
<span class="sd">   by ``cdrecord -msinfo``.  It can be passed as-is to the ``IsoImage`` class.</span>

<span class="sd">   &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MediaCapacity.__init__"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.MediaCapacity.__init__">[docs]</a>   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytesUsed</span><span class="p">,</span> <span class="n">bytesAvailable</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Initializes a capacity object.</span>

<span class="sd">      Raises:</span>
<span class="sd">         IndexError: If the boundaries tuple does not have enough elements</span>
<span class="sd">         ValueError: If the boundaries values are not integers</span>
<span class="sd">         ValueError: If the bytes used and available values are not floats</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_bytesUsed</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bytesUsed</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_bytesAvailable</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">bytesAvailable</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">boundaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

   <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Informal string representation for class instance.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="s2">&quot;utilized </span><span class="si">%s</span><span class="s2"> of </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%.2f%%</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">displayBytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytesUsed</span><span class="p">),</span> <span class="n">displayBytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totalCapacity</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">utilized</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">_getBytesUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target to get the bytes-used value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bytesUsed</span>

   <span class="k">def</span> <span class="nf">_getBytesAvailable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target to get the bytes-available value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bytesAvailable</span>

   <span class="k">def</span> <span class="nf">_getBoundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target to get the boundaries tuple.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundaries</span>

   <span class="k">def</span> <span class="nf">_getTotalCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target to get the total capacity (used + available).</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytesUsed</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytesAvailable</span>

   <span class="k">def</span> <span class="nf">_getUtilized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target to get the percent of capacity which is utilized.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytesAvailable</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
         <span class="k">return</span> <span class="mf">100.0</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bytesUsed</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
         <span class="k">return</span> <span class="mf">0.0</span>
      <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytesUsed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">totalCapacity</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>

   <span class="n">bytesUsed</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getBytesUsed</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Space used on disc, in bytes.&quot;</span><span class="p">)</span>
   <span class="n">bytesAvailable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getBytesAvailable</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Space available on disc, in bytes.&quot;</span><span class="p">)</span>
   <span class="n">boundaries</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getBoundaries</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Session disc boundaries, in terms of ISO sectors.&quot;</span><span class="p">)</span>
   <span class="n">totalCapacity</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getTotalCapacity</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Total capacity of the disc, in bytes.&quot;</span><span class="p">)</span>
   <span class="n">utilized</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getUtilized</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Percentage of the total capacity which is utilized.&quot;</span><span class="p">)</span></div>


<span class="c1">########################################################################</span>
<span class="c1"># _ImageProperties class definition</span>
<span class="c1">########################################################################</span>

<span class="k">class</span> <span class="nc">_ImageProperties</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Simple value object to hold image properties for ``DvdWriter``.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">newDisc</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">mediaLabel</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="kc">None</span>     <span class="c1"># dict mapping path to graft point</span>


<span class="c1">########################################################################</span>
<span class="c1"># CdWriter class definition</span>
<span class="c1">########################################################################</span>

<div class="viewcode-block" id="CdWriter"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter">[docs]</a><span class="k">class</span> <span class="nc">CdWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="c1">######################</span>
   <span class="c1"># Class documentation</span>
   <span class="c1">######################</span>

   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Class representing a device that knows how to write CD media.</span>

<span class="sd">   This is a class representing a device that knows how to write CD media.  It</span>
<span class="sd">   provides common operations for the device, such as ejecting the media,</span>
<span class="sd">   writing an ISO image to the media, or checking for the current media</span>
<span class="sd">   capacity.  It also provides a place to store device attributes, such as</span>
<span class="sd">   whether the device supports writing multisession discs, etc.</span>

<span class="sd">   This class is implemented in terms of the ``eject`` and ``cdrecord``</span>
<span class="sd">   programs, both of which should be available on most UN*X platforms.</span>

<span class="sd">   **Image Writer Interface**</span>

<span class="sd">   The following methods make up the &quot;image writer&quot; interface shared</span>
<span class="sd">   with other kinds of writers (such as DVD writers)::</span>

<span class="sd">      __init__</span>
<span class="sd">      initializeImage()</span>
<span class="sd">      addImageEntry()</span>
<span class="sd">      writeImage()</span>
<span class="sd">      setImageNewDisc()</span>
<span class="sd">      retrieveCapacity()</span>
<span class="sd">      getEstimatedImageSize()</span>

<span class="sd">   Only these methods will be used by other Cedar Backup functionality</span>
<span class="sd">   that expects a compatible image writer.</span>

<span class="sd">   The media attribute is also assumed to be available.</span>

<span class="sd">   **Media Types**</span>

<span class="sd">   This class knows how to write to two different kinds of media, represented</span>
<span class="sd">   by the following constants:</span>

<span class="sd">      - ``MEDIA_CDR_74``: 74-minute CD-R media (650 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDRW_74``: 74-minute CD-RW media (650 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDR_80``: 80-minute CD-R media (700 MB capacity)</span>
<span class="sd">      - ``MEDIA_CDRW_80``: 80-minute CD-RW media (700 MB capacity)</span>

<span class="sd">   Most hardware can read and write both 74-minute and 80-minute CD-R and</span>
<span class="sd">   CD-RW media.  Some older drives may only be able to write CD-R media.</span>
<span class="sd">   The difference between the two is that CD-RW media can be rewritten</span>
<span class="sd">   (erased), while CD-R media cannot be.</span>

<span class="sd">   I do not support any other configurations for a couple of reasons.  The</span>
<span class="sd">   first is that I&#39;ve never tested any other kind of media.  The second is</span>
<span class="sd">   that anything other than 74 or 80 minute is apparently non-standard.</span>

<span class="sd">   **Device Attributes vs. Media Attributes**</span>

<span class="sd">   A given writer instance has two different kinds of attributes associated</span>
<span class="sd">   with it, which I call device attributes and media attributes.  Device</span>
<span class="sd">   attributes are things which can be determined without looking at the</span>
<span class="sd">   media, such as whether the drive supports writing multisession disks or</span>
<span class="sd">   has a tray.  Media attributes are attributes which vary depending on the</span>
<span class="sd">   state of the media, such as the remaining capacity on a disc.  In</span>
<span class="sd">   general, device attributes are available via instance variables and are</span>
<span class="sd">   constant over the life of an object, while media attributes can be</span>
<span class="sd">   retrieved through method calls.</span>

<span class="sd">   **Talking to Hardware**</span>

<span class="sd">   This class needs to talk to CD writer hardware in two different ways:</span>
<span class="sd">   through cdrecord to actually write to the media, and through the</span>
<span class="sd">   filesystem to do things like open and close the tray.</span>

<span class="sd">   Historically, CdWriter has interacted with cdrecord using the scsiId</span>
<span class="sd">   attribute, and with most other utilities using the device attribute.</span>
<span class="sd">   This changed somewhat in Cedar Backup 2.9.0.</span>

<span class="sd">   When Cedar Backup was first written, the only way to interact with</span>
<span class="sd">   cdrecord was by using a SCSI device id.  IDE devices were mapped to</span>
<span class="sd">   pseudo-SCSI devices through the kernel.  Later, extended SCSI &quot;methods&quot;</span>
<span class="sd">   arrived, and it became common to see ``ATA:1,0,0`` or ``ATAPI:0,0,0`` as a</span>
<span class="sd">   way to address IDE hardware.  By late 2006, ``ATA`` and ``ATAPI`` had</span>
<span class="sd">   apparently been deprecated in favor of just addressing the IDE device</span>
<span class="sd">   directly by name, i.e. ``/dev/cdrw``.</span>

<span class="sd">   Because of this latest development, it no longer makes sense to require a</span>
<span class="sd">   CdWriter to be created with a SCSI id -- there might not be one.  So, the</span>
<span class="sd">   passed-in SCSI id is now optional.  Also, there is now a hardwareId</span>
<span class="sd">   attribute.  This attribute is filled in with either the SCSI id (if</span>
<span class="sd">   provided) or the device (otherwise).  The hardware id is the value that</span>
<span class="sd">   will be passed to cdrecord in the ``dev=`` argument.</span>

<span class="sd">   **Testing**</span>

<span class="sd">   It&#39;s rather difficult to test this code in an automated fashion, even if</span>
<span class="sd">   you have access to a physical CD writer drive.  It&#39;s even more difficult</span>
<span class="sd">   to test it if you are running on some build daemon (think of a Debian</span>
<span class="sd">   autobuilder) which can&#39;t be expected to have any hardware or any media</span>
<span class="sd">   that you could write to.</span>

<span class="sd">   Because of this, much of the implementation below is in terms of static</span>
<span class="sd">   methods that are supposed to take defined actions based on their</span>
<span class="sd">   arguments.  Public methods are then implemented in terms of a series of</span>
<span class="sd">   calls to simplistic static methods.  This way, we can test as much as</span>
<span class="sd">   possible of the functionality via testing the static methods, while</span>
<span class="sd">   hoping that if the static methods are called appropriately, things will</span>
<span class="sd">   work properly.  It&#39;s not perfect, but it&#39;s much better than no testing at</span>
<span class="sd">   all.</span>

<span class="sd">   &quot;&quot;&quot;</span>

   <span class="c1">##############</span>
   <span class="c1"># Constructor</span>
   <span class="c1">##############</span>

<div class="viewcode-block" id="CdWriter.__init__"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.__init__">[docs]</a>   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">scsiId</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">driveSpeed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">mediaType</span><span class="o">=</span><span class="n">MEDIA_CDRW_74</span><span class="p">,</span> <span class="n">noEject</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">refreshMediaDelay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ejectDelay</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">unittest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Initializes a CD writer object.</span>

<span class="sd">      The current user must have write access to the device at the time the</span>
<span class="sd">      object is instantiated, or an exception will be thrown.  However, no</span>
<span class="sd">      media-related validation is done, and in fact there is no need for any</span>
<span class="sd">      media to be in the drive until one of the other media attribute-related</span>
<span class="sd">      methods is called.</span>

<span class="sd">      The various instance variables such as ``deviceType``, ``deviceVendor``,</span>
<span class="sd">      etc. might be ``None``, if we&#39;re unable to parse this specific information</span>
<span class="sd">      from the ``cdrecord`` output.  This information is just for reference.</span>

<span class="sd">      The SCSI id is optional, but the device path is required.  If the SCSI id</span>
<span class="sd">      is passed in, then the hardware id attribute will be taken from the SCSI</span>
<span class="sd">      id.  Otherwise, the hardware id will be taken from the device.</span>

<span class="sd">      If cdrecord improperly detects whether your writer device has a tray and</span>
<span class="sd">      can be safely opened and closed, then pass in ``noEject=False``.  This</span>
<span class="sd">      will override the properties and the device will never be ejected.</span>

<span class="sd">      *Note:* The ``unittest`` parameter should never be set to ``True``</span>
<span class="sd">      outside of Cedar Backup code.  It is intended for use in unit testing</span>
<span class="sd">      Cedar Backup internals and has no other sensible purpose.</span>

<span class="sd">      Args:</span>
<span class="sd">         device (Absolute path to a filesystem device, i.e. ``/dev/cdrw``): Filesystem device associated with this writer</span>
<span class="sd">         scsiId (If provided, SCSI id in the form ``[&lt;method&gt;:]scsibus,target,lun``): SCSI id for the device (optional)</span>
<span class="sd">         driveSpeed (Use ``2`` for 2x device, etc. or ``None`` to use device default): Speed at which the drive writes</span>
<span class="sd">         mediaType (One of the valid media type as discussed above): Type of the media that is assumed to be in the drive</span>
<span class="sd">         noEject (Boolean true/false): Overrides properties to indicate that the device does not support eject</span>
<span class="sd">         refreshMediaDelay (Number of seconds, an integer &gt;= 0): Refresh media delay to use, if any</span>
<span class="sd">         ejectDelay (Number of seconds, an integer &gt;= 0): Eject delay to use, if any</span>
<span class="sd">         unittest (Boolean true/false): Turns off certain validations, for use in unit testing</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If the device is not valid for some reason</span>
<span class="sd">         ValueError: If the SCSI id is not in a valid form</span>
<span class="sd">         ValueError: If the drive speed is not an integer &gt;= 1</span>
<span class="sd">         IOError: If device properties could not be read for some reason</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># optionally filled in by initializeImage()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">validateDevice</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">unittest</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_scsiId</span> <span class="o">=</span> <span class="n">validateScsiId</span><span class="p">(</span><span class="n">scsiId</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_driveSpeed</span> <span class="o">=</span> <span class="n">validateDriveSpeed</span><span class="p">(</span><span class="n">driveSpeed</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_media</span> <span class="o">=</span> <span class="n">MediaDefinition</span><span class="p">(</span><span class="n">mediaType</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_noEject</span> <span class="o">=</span> <span class="n">noEject</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_refreshMediaDelay</span> <span class="o">=</span> <span class="n">refreshMediaDelay</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_ejectDelay</span> <span class="o">=</span> <span class="n">ejectDelay</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">unittest</span><span class="p">:</span>
         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deviceType</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceVendor</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceId</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceBufferSize</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceSupportsMulti</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceHasTray</span><span class="p">,</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_deviceCanEject</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retrieveProperties</span><span class="p">()</span></div>


   <span class="c1">#############</span>
   <span class="c1"># Properties</span>
   <span class="c1">#############</span>

   <span class="k">def</span> <span class="nf">_getDevice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>

   <span class="k">def</span> <span class="nf">_getScsiId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the SCSI id value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scsiId</span>

   <span class="k">def</span> <span class="nf">_getHardwareId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the hardware id value.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scsiId</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scsiId</span>

   <span class="k">def</span> <span class="nf">_getDriveSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the drive speed.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_driveSpeed</span>

   <span class="k">def</span> <span class="nf">_getMedia</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the media description.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_media</span>

   <span class="k">def</span> <span class="nf">_getDeviceType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device type.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceType</span>

   <span class="k">def</span> <span class="nf">_getDeviceVendor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device vendor.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceVendor</span>

   <span class="k">def</span> <span class="nf">_getDeviceId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device id.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceId</span>

   <span class="k">def</span> <span class="nf">_getDeviceBufferSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device buffer size.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceBufferSize</span>

   <span class="k">def</span> <span class="nf">_getDeviceSupportsMulti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device-support-multi flag.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceSupportsMulti</span>

   <span class="k">def</span> <span class="nf">_getDeviceHasTray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device-has-tray flag.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceHasTray</span>

   <span class="k">def</span> <span class="nf">_getDeviceCanEject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the device-can-eject flag.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceCanEject</span>

   <span class="k">def</span> <span class="nf">_getRefreshMediaDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the configured refresh media delay, in seconds.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refreshMediaDelay</span>

   <span class="k">def</span> <span class="nf">_getEjectDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Property target used to get the configured eject delay, in seconds.</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ejectDelay</span>

   <span class="n">device</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDevice</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Filesystem device name for this writer.&quot;</span><span class="p">)</span>
   <span class="n">scsiId</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getScsiId</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;SCSI id for the device, in the form ``[&lt;method&gt;:]scsibus,target,lun``.&quot;</span><span class="p">)</span>
   <span class="n">hardwareId</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getHardwareId</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Hardware id for this writer, either SCSI id or device path.&quot;</span><span class="p">)</span>
   <span class="n">driveSpeed</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDriveSpeed</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Speed at which the drive writes.&quot;</span><span class="p">)</span>
   <span class="n">media</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getMedia</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Definition of media that is expected to be in the device.&quot;</span><span class="p">)</span>
   <span class="n">deviceType</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceType</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Type of the device, as returned from ``cdrecord -prcap``.&quot;</span><span class="p">)</span>
   <span class="n">deviceVendor</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceVendor</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Vendor of the device, as returned from ``cdrecord -prcap``.&quot;</span><span class="p">)</span>
   <span class="n">deviceId</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceId</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Device identification, as returned from ``cdrecord -prcap``.&quot;</span><span class="p">)</span>
   <span class="n">deviceBufferSize</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceBufferSize</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Size of the device&#39;s write buffer, in bytes.&quot;</span><span class="p">)</span>
   <span class="n">deviceSupportsMulti</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceSupportsMulti</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Indicates whether device supports multisession discs.&quot;</span><span class="p">)</span>
   <span class="n">deviceHasTray</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceHasTray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Indicates whether the device has a media tray.&quot;</span><span class="p">)</span>
   <span class="n">deviceCanEject</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getDeviceCanEject</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Indicates whether the device supports ejecting its media.&quot;</span><span class="p">)</span>
   <span class="n">refreshMediaDelay</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getRefreshMediaDelay</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Refresh media delay, in seconds.&quot;</span><span class="p">)</span>
   <span class="n">ejectDelay</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getEjectDelay</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Eject delay, in seconds.&quot;</span><span class="p">)</span>


   <span class="c1">#################################################</span>
   <span class="c1"># Methods related to device and media attributes</span>
   <span class="c1">#################################################</span>

<div class="viewcode-block" id="CdWriter.isRewritable"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.isRewritable">[docs]</a>   <span class="k">def</span> <span class="nf">isRewritable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Indicates whether the media is rewritable per configuration.&quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_media</span><span class="o">.</span><span class="n">rewritable</span></div>

   <span class="k">def</span> <span class="nf">_retrieveProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Retrieves properties for a device from ``cdrecord``.</span>

<span class="sd">      The results are returned as a tuple of the object device attributes as</span>
<span class="sd">      returned from :any:`_parsePropertiesOutput`: C{(deviceType, deviceVendor,</span>
<span class="sd">      deviceId, deviceBufferSize, deviceSupportsMulti, deviceHasTray,</span>
<span class="sd">      deviceCanEject)}.</span>

<span class="sd">      Returns:</span>
<span class="sd">          Results tuple as described above</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is a problem talking to the device</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildPropertiesArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hardwareId</span><span class="p">)</span>
      <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">CDRECORD_COMMAND</span><span class="p">)</span>
      <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">returnOutput</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignoreStderr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing cdrecord command to get properties.&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_parsePropertiesOutput</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<div class="viewcode-block" id="CdWriter.retrieveCapacity"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.retrieveCapacity">[docs]</a>   <span class="k">def</span> <span class="nf">retrieveCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entireDisc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useMulti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Retrieves capacity for the current media in terms of a ``MediaCapacity``</span>
<span class="sd">      object.</span>

<span class="sd">      If ``entireDisc`` is passed in as ``True`` the capacity will be for the</span>
<span class="sd">      entire disc, as if it were to be rewritten from scratch.  If the drive</span>
<span class="sd">      does not support writing multisession discs or if ``useMulti`` is passed</span>
<span class="sd">      in as ``False``, the capacity will also be as if the disc were to be</span>
<span class="sd">      rewritten from scratch, but the indicated boundaries value will be</span>
<span class="sd">      ``None``.  The same will happen if the disc cannot be read for some</span>
<span class="sd">      reason.  Otherwise, the capacity (including the boundaries) will</span>
<span class="sd">      represent whatever space remains on the disc to be filled by future</span>
<span class="sd">      sessions.</span>

<span class="sd">      Args:</span>
<span class="sd">         entireDisc (Boolean true/false): Indicates whether to return capacity for entire disc</span>
<span class="sd">         useMulti (Boolean true/false): Indicates whether a multisession disc should be assumed, if possible</span>
<span class="sd">      Returns:</span>
<span class="sd">          ``MediaCapacity`` object describing the capacity of the media</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If the media could not be read for some reason</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getBoundaries</span><span class="p">(</span><span class="n">entireDisc</span><span class="p">,</span> <span class="n">useMulti</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_calculateCapacity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_media</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span></div>

   <span class="k">def</span> <span class="nf">_getBoundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entireDisc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useMulti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Gets the ISO boundaries for the media.</span>

<span class="sd">      If ``entireDisc`` is passed in as ``True`` the boundaries will be ``None``,</span>
<span class="sd">      as if the disc were to be rewritten from scratch.  If the drive does not</span>
<span class="sd">      support writing multisession discs, the returned value will be ``None``.</span>
<span class="sd">      The same will happen if the disc can&#39;t be read for some reason.</span>
<span class="sd">      Otherwise, the returned value will be represent the boundaries of the</span>
<span class="sd">      disc&#39;s current contents.</span>

<span class="sd">      The results are returned as a tuple of (lower, upper) as needed by the</span>
<span class="sd">      ``IsoImage`` class.  Note that these values are in terms of ISO sectors,</span>
<span class="sd">      not bytes.  Clients should generally consider the boundaries value</span>
<span class="sd">      opaque, however.</span>

<span class="sd">      Args:</span>
<span class="sd">         entireDisc (Boolean true/false): Indicates whether to return capacity for entire disc</span>
<span class="sd">         useMulti (Boolean true/false): Indicates whether a multisession disc should be assumed, if possible</span>
<span class="sd">      Returns:</span>
<span class="sd">          Boundaries tuple or ``None``, as described above</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If the media could not be read for some reason</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceSupportsMulti</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Device does not support multisession discs; returning boundaries None.&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="k">elif</span> <span class="ow">not</span> <span class="n">useMulti</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Use multisession flag is False; returning boundaries None.&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="k">elif</span> <span class="n">entireDisc</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Entire disc flag is True; returning boundaries None.&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildBoundariesArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hardwareId</span><span class="p">)</span>
         <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">CDRECORD_COMMAND</span><span class="p">)</span>
         <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">returnOutput</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignoreStderr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing cdrecord command to get capacity.&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unable to read disc (might not be initialized); returning boundaries of None.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
         <span class="n">boundaries</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_parseBoundariesOutput</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">boundaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Returning disc boundaries: None&quot;</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Returning disc boundaries: (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
         <span class="k">return</span> <span class="n">boundaries</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_calculateCapacity</span><span class="p">(</span><span class="n">media</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Calculates capacity for the media in terms of boundaries.</span>

<span class="sd">      If ``boundaries`` is ``None`` or the lower bound is 0 (zero), then the</span>
<span class="sd">      capacity will be for the entire disc minus the initial lead in.</span>
<span class="sd">      Otherwise, capacity will be as if the caller wanted to add an additional</span>
<span class="sd">      session to the end of the existing data on the disc.</span>

<span class="sd">      Args:</span>
<span class="sd">         media: MediaDescription object describing the media capacity</span>
<span class="sd">         boundaries: Session boundaries as returned from :any:`_getBoundaries`</span>

<span class="sd">      Returns:</span>
<span class="sd">          ``MediaCapacity`` object describing the capacity of the media</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">boundaries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Capacity calculations are based on a complete disc rewrite.&quot;</span><span class="p">)</span>
         <span class="n">sectorsAvailable</span> <span class="o">=</span> <span class="n">media</span><span class="o">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">media</span><span class="o">.</span><span class="n">initialLeadIn</span>
         <span class="k">if</span> <span class="n">sectorsAvailable</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">sectorsAvailable</span> <span class="o">=</span> <span class="mf">0.0</span>
         <span class="n">bytesUsed</span> <span class="o">=</span> <span class="mf">0.0</span>
         <span class="n">bytesAvailable</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="n">sectorsAvailable</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">,</span> <span class="n">UNIT_BYTES</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Capacity calculations are based on a new ISO session.&quot;</span><span class="p">)</span>
         <span class="n">sectorsAvailable</span> <span class="o">=</span> <span class="n">media</span><span class="o">.</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">media</span><span class="o">.</span><span class="n">leadIn</span>
         <span class="k">if</span> <span class="n">sectorsAvailable</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">sectorsAvailable</span> <span class="o">=</span> <span class="mf">0.0</span>
         <span class="n">bytesUsed</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">UNIT_SECTORS</span><span class="p">,</span> <span class="n">UNIT_BYTES</span><span class="p">)</span>
         <span class="n">bytesAvailable</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="n">sectorsAvailable</span><span class="p">,</span> <span class="n">UNIT_SECTORS</span><span class="p">,</span> <span class="n">UNIT_BYTES</span><span class="p">)</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Used [</span><span class="si">%s</span><span class="s2">], available [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">bytesUsed</span><span class="p">),</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">bytesAvailable</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">MediaCapacity</span><span class="p">(</span><span class="n">bytesUsed</span><span class="p">,</span> <span class="n">bytesAvailable</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span>


   <span class="c1">#######################################################</span>
   <span class="c1"># Methods used for working with the internal ISO image</span>
   <span class="c1">#######################################################</span>

<div class="viewcode-block" id="CdWriter.initializeImage"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.initializeImage">[docs]</a>   <span class="k">def</span> <span class="nf">initializeImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDisc</span><span class="p">,</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">mediaLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Initializes the writer&#39;s associated ISO image.</span>

<span class="sd">      This method initializes the ``image`` instance variable so that the caller</span>
<span class="sd">      can use the ``addImageEntry`` method.  Once entries have been added, the</span>
<span class="sd">      ``writeImage`` method can be called with no arguments.</span>

<span class="sd">      Args:</span>
<span class="sd">         newDisc (Boolean true/false): Indicates whether the disc should be re-initialized</span>
<span class="sd">         tmpdir (String representing a directory path on disk): Temporary directory to use if needed</span>
<span class="sd">         mediaLabel (String, no more than 25 characters long): Media label to be applied to the image, if any</span>

<span class="sd">      &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="n">_ImageProperties</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">newDisc</span> <span class="o">=</span> <span class="n">newDisc</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">encodePath</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">mediaLabel</span> <span class="o">=</span> <span class="n">mediaLabel</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># mapping from path to graft point (if any)</span></div>

<div class="viewcode-block" id="CdWriter.addImageEntry"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.addImageEntry">[docs]</a>   <span class="k">def</span> <span class="nf">addImageEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">graftPoint</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Adds a filepath entry to the writer&#39;s associated ISO image.</span>

<span class="sd">      The contents of the filepath -- but not the path itself -- will be added</span>
<span class="sd">      to the image at the indicated graft point.  If you don&#39;t want to use a</span>
<span class="sd">      graft point, just pass ``None``.</span>

<span class="sd">      *Note:* Before calling this method, you must call :any:`initializeImage`.</span>

<span class="sd">      Args:</span>
<span class="sd">         path (String representing a path on disk): File or directory to be added to the image</span>
<span class="sd">         graftPoint (String representing a graft point path, as described above): Graft point to be used when adding this entry</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If initializeImage() was not previously called</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must call initializeImage() before using this method.&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Path [</span><span class="si">%s</span><span class="s2">] does not exist.&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">graftPoint</span></div>

<div class="viewcode-block" id="CdWriter.setImageNewDisc"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.setImageNewDisc">[docs]</a>   <span class="k">def</span> <span class="nf">setImageNewDisc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newDisc</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Resets (overrides) the newDisc flag on the internal image.</span>
<span class="sd">      Args:</span>
<span class="sd">         newDisc: New disc flag to set</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If initializeImage() was not previously called</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must call initializeImage() before using this method.&quot;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">newDisc</span> <span class="o">=</span> <span class="n">newDisc</span></div>

<div class="viewcode-block" id="CdWriter.getEstimatedImageSize"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.getEstimatedImageSize">[docs]</a>   <span class="k">def</span> <span class="nf">getEstimatedImageSize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Gets the estimated size of the image associated with the writer.</span>
<span class="sd">      Returns:</span>
<span class="sd">          Estimated size of the image, in bytes</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is a problem calling ``mkisofs``</span>
<span class="sd">         ValueError: If initializeImage() was not previously called</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must call initializeImage() before using this method.&quot;</span><span class="p">)</span>
      <span class="n">image</span> <span class="o">=</span> <span class="n">IsoImage</span><span class="p">()</span>
      <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
         <span class="n">image</span><span class="o">.</span><span class="n">addEntry</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="n">path</span><span class="p">],</span> <span class="n">override</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contentsOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">getEstimatedSize</span><span class="p">()</span></div>


   <span class="c1">######################################</span>
   <span class="c1"># Methods which expose device actions</span>
   <span class="c1">######################################</span>

<div class="viewcode-block" id="CdWriter.openTray"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.openTray">[docs]</a>   <span class="k">def</span> <span class="nf">openTray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Opens the device&#39;s tray and leaves it open.</span>

<span class="sd">      This only works if the device has a tray and supports ejecting its media.</span>
<span class="sd">      We have no way to know if the tray is currently open or closed, so we</span>
<span class="sd">      just send the appropriate command and hope for the best.  If the device</span>
<span class="sd">      does not have a tray or does not support ejecting its media, then we do</span>
<span class="sd">      nothing.</span>

<span class="sd">      If the writer was constructed with ``noEject=True``, then this is a no-op.</span>

<span class="sd">      Starting with Debian wheezy on my backup hardware, I started seeing</span>
<span class="sd">      consistent problems with the eject command.  I couldn&#39;t tell whether</span>
<span class="sd">      these problems were due to the device management system or to the new</span>
<span class="sd">      kernel (3.2.0).  Initially, I saw simple eject failures, possibly because</span>
<span class="sd">      I was opening and closing the tray too quickly.  I worked around that</span>
<span class="sd">      behavior with the new ejectDelay flag.</span>

<span class="sd">      Later, I sometimes ran into issues after writing an image to a disc:</span>
<span class="sd">      eject would give errors like &quot;unable to eject, last error: Inappropriate</span>
<span class="sd">      ioctl for device&quot;.  Various sources online (like Ubuntu bug #875543)</span>
<span class="sd">      suggested that the drive was being locked somehow, and that the</span>
<span class="sd">      workaround was to run &#39;eject -i off&#39; to unlock it.  Sure enough, that</span>
<span class="sd">      fixed the problem for me, so now it&#39;s a normal error-handling strategy.</span>

<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is an error talking to the device</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noEject</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceHasTray</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceCanEject</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildOpenTrayArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">EJECT_COMMAND</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
               <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Eject failed; attempting kludge of unlocking the tray before retrying.&quot;</span><span class="p">)</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">unlockTray</span><span class="p">()</span>
               <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">EJECT_COMMAND</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
               <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                  <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing eject command to open tray (failed even after unlocking tray).&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>
               <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Kludge was apparently successful.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ejectDelay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Per configuration, sleeping </span><span class="si">%d</span><span class="s2"> seconds after opening tray.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ejectDelay</span><span class="p">)</span>
               <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ejectDelay</span><span class="p">)</span></div>

<div class="viewcode-block" id="CdWriter.unlockTray"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.unlockTray">[docs]</a>   <span class="k">def</span> <span class="nf">unlockTray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Unlocks the device&#39;s tray.</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is an error talking to the device</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildUnlockTrayArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
      <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">EJECT_COMMAND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing eject command to unlock tray.&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="CdWriter.closeTray"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.closeTray">[docs]</a>   <span class="k">def</span> <span class="nf">closeTray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Closes the device&#39;s tray.</span>

<span class="sd">      This only works if the device has a tray and supports ejecting its media.</span>
<span class="sd">      We have no way to know if the tray is currently open or closed, so we</span>
<span class="sd">      just send the appropriate command and hope for the best.  If the device</span>
<span class="sd">      does not have a tray or does not support ejecting its media, then we do</span>
<span class="sd">      nothing.</span>

<span class="sd">      If the writer was constructed with ``noEject=True``, then this is a no-op.</span>

<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is an error talking to the device</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noEject</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceHasTray</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceCanEject</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildCloseTrayArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">EJECT_COMMAND</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing eject command to close tray.&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="CdWriter.refreshMedia"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.refreshMedia">[docs]</a>   <span class="k">def</span> <span class="nf">refreshMedia</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Opens and then immediately closes the device&#39;s tray, to refresh the</span>
<span class="sd">      device&#39;s idea of the media.</span>

<span class="sd">      Sometimes, a device gets confused about the state of its media.  Often,</span>
<span class="sd">      all it takes to solve the problem is to eject the media and then</span>
<span class="sd">      immediately reload it.  (There are also configurable eject and refresh</span>
<span class="sd">      media delays which can be applied, for situations where this makes a</span>
<span class="sd">      difference.)</span>

<span class="sd">      This only works if the device has a tray and supports ejecting its media.</span>
<span class="sd">      We have no way to know if the tray is currently open or closed, so we</span>
<span class="sd">      just send the appropriate command and hope for the best.  If the device</span>
<span class="sd">      does not have a tray or does not support ejecting its media, then we do</span>
<span class="sd">      nothing.  The configured delays still apply, though.</span>

<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is an error talking to the device</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">openTray</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">closeTray</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">unlockTray</span><span class="p">()</span>  <span class="c1"># on some systems, writing a disc leaves the tray locked, yikes!</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refreshMediaDelay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Per configuration, sleeping </span><span class="si">%d</span><span class="s2"> seconds to stabilize media state.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refreshMediaDelay</span><span class="p">)</span>
         <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refreshMediaDelay</span><span class="p">)</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Media refresh complete; hopefully media state is stable now.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CdWriter.writeImage"><a class="viewcode-back" href="../../../CedarBackup3.writers.html#CedarBackup3.writers.cdwriter.CdWriter.writeImage">[docs]</a>   <span class="k">def</span> <span class="nf">writeImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imagePath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newDisc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">writeMulti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Writes an ISO image to the media in the device.</span>

<span class="sd">      If ``newDisc`` is passed in as ``True``, we assume that the entire disc</span>
<span class="sd">      will be overwritten, and the media will be blanked before writing it if</span>
<span class="sd">      possible (i.e. if the media is rewritable).</span>

<span class="sd">      If ``writeMulti`` is passed in as ``True``, then a multisession disc will</span>
<span class="sd">      be written if possible (i.e. if the drive supports writing multisession</span>
<span class="sd">      discs).</span>

<span class="sd">      if ``imagePath`` is passed in as ``None``, then the existing image</span>
<span class="sd">      configured with ``initializeImage`` will be used.  Under these</span>
<span class="sd">      circumstances, the passed-in ``newDisc`` flag will be ignored.</span>

<span class="sd">      By default, we assume that the disc can be written multisession and that</span>
<span class="sd">      we should append to the current contents of the disc.  In any case, the</span>
<span class="sd">      ISO image must be generated appropriately (i.e. must take into account</span>
<span class="sd">      any existing session boundaries, etc.)</span>

<span class="sd">      Args:</span>
<span class="sd">         imagePath (String representing a path on disk): Path to an ISO image on disk, or ``None`` to use writer&#39;s image</span>
<span class="sd">         newDisc (Boolean true/false): Indicates whether the entire disc will overwritten</span>
<span class="sd">         writeMulti (Boolean true/false): Indicates whether a multisession disc should be written, if possible</span>
<span class="sd">      Raises:</span>
<span class="sd">         ValueError: If the image path is not absolute</span>
<span class="sd">         ValueError: If some path cannot be encoded properly</span>
<span class="sd">         IOError: If the media could not be written to for some reason</span>
<span class="sd">         ValueError: If no image is passed in and initializeImage() was not previously called</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">imagePath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must call initializeImage() before using this method with no image path.&quot;</span><span class="p">)</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="n">imagePath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_createImage</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_writeImage</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">writeMulti</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">newDisc</span><span class="p">)</span>
         <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">imagePath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">imagePath</span><span class="p">):</span>
               <span class="k">try</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">imagePath</span><span class="p">)</span>
               <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="n">imagePath</span> <span class="o">=</span> <span class="n">encodePath</span><span class="p">(</span><span class="n">imagePath</span><span class="p">)</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">imagePath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image path must be absolute.&quot;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_writeImage</span><span class="p">(</span><span class="n">imagePath</span><span class="p">,</span> <span class="n">writeMulti</span><span class="p">,</span> <span class="n">newDisc</span><span class="p">)</span></div>

   <span class="k">def</span> <span class="nf">_createImage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Creates an ISO image based on configuration in self._image.</span>
<span class="sd">      Returns:</span>
<span class="sd">          Path to the newly-created ISO image on disk</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is an error writing the image to disk</span>
<span class="sd">         ValueError: If there are no filesystem entries in the image</span>
<span class="sd">         ValueError: If a path cannot be encoded properly</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">capacity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrieveCapacity</span><span class="p">(</span><span class="n">entireDisc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">newDisc</span><span class="p">)</span>
      <span class="n">image</span> <span class="o">=</span> <span class="n">IsoImage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">capacity</span><span class="o">.</span><span class="n">boundaries</span><span class="p">)</span>
      <span class="n">image</span><span class="o">.</span><span class="n">volumeId</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">mediaLabel</span>  <span class="c1"># may be None, which is also valid</span>
      <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
         <span class="n">image</span><span class="o">.</span><span class="n">addEntry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">override</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contentsOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">size</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">getEstimatedSize</span><span class="p">()</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Image size will be </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
      <span class="n">available</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">.</span><span class="n">bytesAvailable</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Media capacity: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">available</span><span class="p">))</span>
      <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">available</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Image [</span><span class="si">%s</span><span class="s2">] does not fit in available capacity [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">displayBytes</span><span class="p">(</span><span class="n">available</span><span class="p">))</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Media does not contain enough capacity to store image.&quot;</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="o">.</span><span class="n">tmpdir</span><span class="p">)</span>
         <span class="k">try</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
         <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
         <span class="n">image</span><span class="o">.</span><span class="n">writeImage</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Completed creating image [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">path</span>
      <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
         <span class="k">raise</span> <span class="n">e</span>

   <span class="k">def</span> <span class="nf">_writeImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imagePath</span><span class="p">,</span> <span class="n">writeMulti</span><span class="p">,</span> <span class="n">newDisc</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Write an ISO image to disc using cdrecord.</span>
<span class="sd">      The disc is blanked first if ``newDisc`` is ``True``.</span>
<span class="sd">      Args:</span>
<span class="sd">         imagePath: Path to an ISO image on disk</span>
<span class="sd">         writeMulti: Indicates whether a multisession disc should be written, if possible</span>
<span class="sd">         newDisc: Indicates whether the entire disc will overwritten</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">newDisc</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_blankMedia</span><span class="p">()</span>
      <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildWriteArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hardwareId</span><span class="p">,</span> <span class="n">imagePath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_driveSpeed</span><span class="p">,</span> <span class="n">writeMulti</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deviceSupportsMulti</span><span class="p">)</span>
      <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">CDRECORD_COMMAND</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing command to write disc.&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">refreshMedia</span><span class="p">()</span>

   <span class="k">def</span> <span class="nf">_blankMedia</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Blanks the media in the device, if the media is rewritable.</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If the media could not be written to for some reason</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isRewritable</span><span class="p">():</span>
         <span class="n">args</span> <span class="o">=</span> <span class="n">CdWriter</span><span class="o">.</span><span class="n">_buildBlankArgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hardwareId</span><span class="p">)</span>
         <span class="n">command</span> <span class="o">=</span> <span class="n">resolveCommand</span><span class="p">(</span><span class="n">CDRECORD_COMMAND</span><span class="p">)</span>
         <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error (</span><span class="si">%d</span><span class="s2">) executing command to blank disc.&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">refreshMedia</span><span class="p">()</span>


   <span class="c1">#######################################</span>
   <span class="c1"># Methods used to parse command output</span>
   <span class="c1">#######################################</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_parsePropertiesOutput</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Parses the output from a ``cdrecord`` properties command.</span>

<span class="sd">      The ``output`` parameter should be a list of strings as returned from</span>
<span class="sd">      ``executeCommand`` for a ``cdrecord`` command with arguments as from</span>
<span class="sd">      ``_buildPropertiesArgs``.  The list of strings will be parsed to yield</span>
<span class="sd">      information about the properties of the device.</span>

<span class="sd">      The output is expected to be a huge long list of strings.  Unfortunately,</span>
<span class="sd">      the strings aren&#39;t in a completely regular format.  However, the format</span>
<span class="sd">      of individual lines seems to be regular enough that we can look for</span>
<span class="sd">      specific values.  Two kinds of parsing take place: one kind of parsing</span>
<span class="sd">      picks out out specific values like the device id, device vendor, etc.</span>
<span class="sd">      The other kind of parsing just sets a boolean flag ``True`` if a matching</span>
<span class="sd">      line is found.  All of the parsing is done with regular expressions.</span>

<span class="sd">      Right now, pretty much nothing in the output is required and we should</span>
<span class="sd">      parse an empty document successfully (albeit resulting in a device that</span>
<span class="sd">      can&#39;t eject, doesn&#39;t have a tray and doesnt&#39;t support multisession</span>
<span class="sd">      discs).   I had briefly considered erroring out if certain lines weren&#39;t</span>
<span class="sd">      found or couldn&#39;t be parsed, but that seems like a bad idea given that</span>
<span class="sd">      most of the information is just for reference.</span>

<span class="sd">      The results are returned as a tuple of the object device attributes:</span>
<span class="sd">      C{(deviceType, deviceVendor, deviceId, deviceBufferSize,</span>
<span class="sd">      deviceSupportsMulti, deviceHasTray, deviceCanEject)}.</span>

<span class="sd">      Args:</span>
<span class="sd">         output: Output from a ``cdrecord -prcap`` command</span>

<span class="sd">      Returns:</span>
<span class="sd">          Results tuple as described above</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is problem parsing the output</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">deviceType</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">deviceVendor</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">deviceId</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">deviceBufferSize</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">deviceSupportsMulti</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">deviceHasTray</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">deviceCanEject</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">typePattern</span>   <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^Device type\s*:\s*)(.*)(\s*)(.*$)&quot;</span><span class="p">)</span>
      <span class="n">vendorPattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^Vendor_info\s*:\s*&#39;\s*)(.*?)(\s*&#39;)(.*$)&quot;</span><span class="p">)</span>
      <span class="n">idPattern</span>     <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^Identifikation\s*:\s*&#39;\s*)(.*?)(\s*&#39;)(.*$)&quot;</span><span class="p">)</span>
      <span class="n">bufferPattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^\s*Buffer size in KB:\s*)(.*?)(\s*$)&quot;</span><span class="p">)</span>
      <span class="n">multiPattern</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*Does read multi-session.*$&quot;</span><span class="p">)</span>
      <span class="n">trayPattern</span>   <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*Loading mechanism type: tray.*$&quot;</span><span class="p">)</span>
      <span class="n">ejectPattern</span>  <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*Does support ejection.*$&quot;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
         <span class="k">if</span> <span class="n">typePattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceType</span> <span class="o">=</span>  <span class="n">typePattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device type is [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">deviceType</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">vendorPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceVendor</span> <span class="o">=</span> <span class="n">vendorPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device vendor is [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">deviceVendor</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">idPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceId</span> <span class="o">=</span> <span class="n">idPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device id is [</span><span class="si">%s</span><span class="s2">].&quot;</span><span class="p">,</span> <span class="n">deviceId</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">bufferPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
               <span class="n">sectors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bufferPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
               <span class="n">deviceBufferSize</span> <span class="o">=</span> <span class="n">convertSize</span><span class="p">(</span><span class="n">sectors</span><span class="p">,</span> <span class="n">UNIT_KBYTES</span><span class="p">,</span> <span class="n">UNIT_BYTES</span><span class="p">)</span>
               <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device buffer size is [</span><span class="si">%d</span><span class="s2">] bytes.&quot;</span><span class="p">,</span> <span class="n">deviceBufferSize</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="k">pass</span>
         <span class="k">elif</span> <span class="n">multiPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceSupportsMulti</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device does support multisession discs.&quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">trayPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceHasTray</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device has a tray.&quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">ejectPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">deviceCanEject</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Device can eject its media.&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">deviceType</span><span class="p">,</span> <span class="n">deviceVendor</span><span class="p">,</span> <span class="n">deviceId</span><span class="p">,</span> <span class="n">deviceBufferSize</span><span class="p">,</span> <span class="n">deviceSupportsMulti</span><span class="p">,</span> <span class="n">deviceHasTray</span><span class="p">,</span> <span class="n">deviceCanEject</span><span class="p">)</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_parseBoundariesOutput</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Parses the output from a ``cdrecord`` capacity command.</span>

<span class="sd">      The ``output`` parameter should be a list of strings as returned from</span>
<span class="sd">      ``executeCommand`` for a ``cdrecord`` command with arguments as from</span>
<span class="sd">      ``_buildBoundaryArgs``.  The list of strings will be parsed to yield</span>
<span class="sd">      information about the capacity of the media in the device.</span>

<span class="sd">      Basically, we expect the list of strings to include just one line, a pair</span>
<span class="sd">      of values.  There isn&#39;t supposed to be whitespace, but we allow it anyway</span>
<span class="sd">      in the regular expression.  Any lines below the one line we parse are</span>
<span class="sd">      completely ignored.  It would be a good idea to ignore ``stderr`` when</span>
<span class="sd">      executing the ``cdrecord`` command that generates output for this method,</span>
<span class="sd">      because sometimes ``cdrecord`` spits out kernel warnings about the actual</span>
<span class="sd">      output.</span>

<span class="sd">      The results are returned as a tuple of (lower, upper) as needed by the</span>
<span class="sd">      ``IsoImage`` class.  Note that these values are in terms of ISO sectors,</span>
<span class="sd">      not bytes.  Clients should generally consider the boundaries value</span>
<span class="sd">      opaque, however.</span>

<span class="sd">      *Note:* If the boundaries output can&#39;t be parsed, we return ``None``.</span>

<span class="sd">      Args:</span>
<span class="sd">         output: Output from a ``cdrecord -msinfo`` command</span>

<span class="sd">      Returns:</span>
<span class="sd">          Boundaries tuple as described above</span>
<span class="sd">      Raises:</span>
<span class="sd">         IOError: If there is problem parsing the output</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
         <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unable to read disc (might not be initialized); returning full capacity.&quot;</span><span class="p">)</span>
         <span class="k">return</span> <span class="kc">None</span>
      <span class="n">boundaryPattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(^\s*)([0-9]*)(\s*,\s*)([0-9]*)(\s*$)&quot;</span><span class="p">)</span>
      <span class="n">parsed</span> <span class="o">=</span> <span class="n">boundaryPattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Unable to parse output of boundaries command.&quot;</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">boundaries</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="p">)</span>
      <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Unable to parse output of boundaries command.&quot;</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">boundaries</span>


   <span class="c1">#################################</span>
   <span class="c1"># Methods used to build commands</span>
   <span class="c1">#################################</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildOpenTrayArgs</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``eject`` command.</span>

<span class="sd">      The arguments will cause the ``eject`` command to open the tray and</span>
<span class="sd">      eject the media.  No validation is done by this method as to whether</span>
<span class="sd">      this action actually makes sense.</span>

<span class="sd">      Args:</span>
<span class="sd">         device: Filesystem device name for this writer, i.e. ``/dev/cdrw``</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildUnlockTrayArgs</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``eject`` command.</span>

<span class="sd">      The arguments will cause the ``eject`` command to unlock the tray.</span>

<span class="sd">      Args:</span>
<span class="sd">         device: Filesystem device name for this writer, i.e. ``/dev/cdrw``</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-i&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildCloseTrayArgs</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``eject`` command.</span>

<span class="sd">      The arguments will cause the ``eject`` command to close the tray and reload</span>
<span class="sd">      the media.  No validation is done by this method as to whether this</span>
<span class="sd">      action actually makes sense.</span>

<span class="sd">      Args:</span>
<span class="sd">         device: Filesystem device name for this writer, i.e. ``/dev/cdrw``</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-t&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildPropertiesArgs</span><span class="p">(</span><span class="n">hardwareId</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``cdrecord`` command.</span>

<span class="sd">      The arguments will cause the ``cdrecord`` command to ask the device</span>
<span class="sd">      for a list of its capacities via the ``-prcap`` switch.</span>

<span class="sd">      Args:</span>
<span class="sd">         hardwareId: Hardware id for the device (either SCSI id or device path)</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-prcap&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dev=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hardwareId</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildBoundariesArgs</span><span class="p">(</span><span class="n">hardwareId</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``cdrecord`` command.</span>

<span class="sd">      The arguments will cause the ``cdrecord`` command to ask the device for</span>
<span class="sd">      the current multisession boundaries of the media using the ``-msinfo``</span>
<span class="sd">      switch.</span>

<span class="sd">      Args:</span>
<span class="sd">         hardwareId: Hardware id for the device (either SCSI id or device path)</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-msinfo&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dev=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hardwareId</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildBlankArgs</span><span class="p">(</span><span class="n">hardwareId</span><span class="p">,</span> <span class="n">driveSpeed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``cdrecord`` command.</span>

<span class="sd">      The arguments will cause the ``cdrecord`` command to blank the media in</span>
<span class="sd">      the device identified by ``hardwareId``.  No validation is done by this method</span>
<span class="sd">      as to whether the action makes sense (i.e. to whether the media even can</span>
<span class="sd">      be blanked).</span>

<span class="sd">      Args:</span>
<span class="sd">         hardwareId: Hardware id for the device (either SCSI id or device path)</span>
<span class="sd">         driveSpeed: Speed at which the drive writes</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;blank=fast&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">driveSpeed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;speed=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">driveSpeed</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dev=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hardwareId</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span>

   <span class="nd">@staticmethod</span>
   <span class="k">def</span> <span class="nf">_buildWriteArgs</span><span class="p">(</span><span class="n">hardwareId</span><span class="p">,</span> <span class="n">imagePath</span><span class="p">,</span> <span class="n">driveSpeed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">writeMulti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Builds a list of arguments to be passed to a ``cdrecord`` command.</span>

<span class="sd">      The arguments will cause the ``cdrecord`` command to write the indicated</span>
<span class="sd">      ISO image (``imagePath``) to the media in the device identified by</span>
<span class="sd">      ``hardwareId``.  The ``writeMulti`` argument controls whether to write a</span>
<span class="sd">      multisession disc.  No validation is done by this method as to whether</span>
<span class="sd">      the action makes sense (i.e. to whether the device even can write</span>
<span class="sd">      multisession discs, for instance).</span>

<span class="sd">      Args:</span>
<span class="sd">         hardwareId: Hardware id for the device (either SCSI id or device path)</span>
<span class="sd">         imagePath: Path to an ISO image on disk</span>
<span class="sd">         driveSpeed: Speed at which the drive writes</span>
<span class="sd">         writeMulti: Indicates whether to write a multisession disc</span>

<span class="sd">      Returns:</span>
<span class="sd">          List suitable for passing to :any:`util.executeCommand` as ``args``</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">driveSpeed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;speed=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">driveSpeed</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;dev=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hardwareId</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">writeMulti</span><span class="p">:</span>
         <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-multi&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-data&quot;</span><span class="p">)</span>
      <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imagePath</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">args</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Cedar Backup v3  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.9.
    </div>
  </body>
</html>
